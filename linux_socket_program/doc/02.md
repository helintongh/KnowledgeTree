### socket的网络编程基础2(工具和设置socket属性的函数)

### 1.常用网络调式工具

Linux下网络抓包工具是tcpdump


 tcpdump工具: 用来截获网络接口中的数据包(以太网帧)
 	
 基本使用:
 	
 - 截获指定IP地址上的流过的数据包 : `tcpdump host 192.168.1.175`
 	
 - 截获指定端口上流过的数据包: `tcpdump port 6000`
 	
 - 截获指定传输层协议流过的数据包 `tcpdump udp`
 
 - 截获指定端口和IP地址上流过的数据包 `tcpdump tcp port 8080 and host 192.168.1.175`
 
 - 将截获的数据报文保存成 .cap文件，方便用wireshark抓包软件分析。(使用 -w选项)
    `tcpdump port 800 and host 192.168.1.175 -w ./data.cap`

	  
windwo下网络抓包工具:wireshark抓包和分析包工具。该工具是截获网络接口的数据流，并解析各个网络协议头，是学习网络协议，分析数据包码流很好的工具.

### 2.广播和组播

1. 广播的概念
	
- 单播:发送主机将数据包只发送给一个主机。

- 广播:发送主机将数据包同时发给局域网中的所有主机。

- 组播:发送主机将数据包发送给加入某个多播组的主机.

	 	  	
2. 最大的主机地址为广播地址,例:192.168.1.255
  
3. 广播编程流程

	- 广播发送流程

	创建udp socket--->设置socket广播属性--->指定接收地址为广播地址--->发送数据报文--->关闭socket
	   `socket---------->setsockopt--------->指定接收地址192.168.1.255--->sendto------->close`
   
	- 广播接收流程

	创建udp socket----->绑定本机地址和端口(IP地址:INADDR_ANY)------>接收广播报文------>关闭socket
     `socket--------->bind--------------->sendto---------------->recvfrom---------->close`	与普通udp客户端唯一的不同在于地址为INADDR_ANY。
     	
  
4. 组播编程流程

- 组播IP地址: 224.0.0.1 ~ 239.255.255.255
  	 	
- 组播发送流程
  	    创建UDP socket--->指定接收地址为组播地址--->发送数据报文---->关闭socket
  	    
- 组播接收流程
  	    创建UDP socket--->绑定本机地址和端口(IP地址:INADDR_ANY)--->网络接口加入多播组--->接收数据--->关闭socket
  	       
由上面的知识可知,还需要一些信息来改变socket的属性。

### 3.socket属性相关函数

socket函数分为查询网络信息相关函数和设置/获取socket属性函数。这里我把两者一起介绍。

#### 3.1查询网络信息相关函数的使用

```C
/* 函数原型 : */
int gethostname(char *name, size_t len)
/*
功能: 获得主机名称
参数: name  保存返回的主机名称
      len   name的长度
返回值 该函数返回0表示成功，否则失败。
*/
//实例
iret = gethostname(hostName, 50);

/* 函数原型 : */
int getsockname(int sockfd,struct sockaddr* localaddr,socklen_t *addrlen);
/*
功能: 获取本机套接字
参数: sockfd  socket描述符
	localaddr  保存返回的本机地址
	addrlen  保存地址长度

返回值 若成功则为0，失败则为-1
*/
// 实例
iret = getsockname(clientSocket, (struct sockaddr *)&peerAddr, &addr_len);

/* 函数原型 : */
int getpeername(int sockfd,struct sockaddr* peeraddr,socklen_t *addrlen);
/*
功能： 获取已连接的对端套接字
参数: sockfd  socket描述符
	  peeraddr  保存返回的远程主机协议地址
	  addrlen  保存地址长度
	
返回值 若成功则为0，失败则为-1
*/
iret = getpeername(clientSocket, (struct sockaddr *)&peerAddr, &addr_len);
	 	   
/* 函数原型: */
struct hostent *gethostbyname(const char * hostname); 
/*
功能: 根据主机名称或域名获取相应主机地址结构相关信息
参数: hostname 主机名称或域名
返回值: 成功返回一个 struct hostent结构体指针，出错返回 NULL
*/
struct hostent *phost=NULL;
phost = gethostbyname("www.qq.com");
	 

/* struct hostent定义如下: */
	 	  	
struct hostent
{
	char 	*h_name; 		//官方主机名称
	char 	**h_aliases;	 //主机别名
	int		 h_addrtype; 	//地址类型, IPV4 --> AF_INET
	int		 h_length; 		//地址长度: 4
	char 	**h_addr_list; 	//二进制主机地址列表
};
	 	  
```

#### 3.2设置和获取socket属性函数的使用

```C++
/* 函数原型: */ 
int setsockopt(int sockfd,int level,int optname,const void*optval,socklen_t optlen)
/*	   
功能: 设置socket属性
参数:
	sockfd  socket描述符
	level   需要设置的选项定义的层次.可以取三种值:
						SOL_SOCKET:通用套接字选项.
						IPPROTO_IP:IP选项.
						IPPROTO_TCP:TCP选项
	optname  需要设置的选项名称
	optval   指针，指向存放选项值的缓冲区
	optlen   选项缓冲区的长度

返回值 成功返回 0，出错返回相应的错误代码
		  
常用选项:
	SO_REUSEADDR  允许重用本地地址和端口
	
	防止服务器出现意外而导致没有将这个端口释放，如果设置了该选项，服务器重新启动后，你还可以用这个端口，
	因为你已经规定可以重用了，如果没有设置该选项话，你就会得到提示，ADDR已在使用中。 
*/		  	
// setsockopt使用如下
int reuse = 1;
int optlen = sizeof(int);
listen_sock=socket(...);
//设置服务器允许重用本地地址和端口
iret = setsockopt(listen_sock, SOL_SOCKET,SO_REUSEADDR, &reuse,optlen)
bind(listen_sock...)
		 

/*函数原型:*/
int getsockopt(int sockfd,int level,int optname,const void*optval,socklen_t *optlen)
/*  	 
功能: 获取socket属性
参数以及返回值 同setsockopt一致
*/
// 使用场景	例如: 获取listen_sock SO_REUSEADDR属性的值
iret = getsockopt(listen_sock, SOL_SOCKET,SO_REUSEADDR, &reuse, &optlen)
```